% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CTDS.R
\name{ct_QAIC}
\alias{ct_QAIC}
\title{Compute QAIC for a set of detection function models}
\usage{
ct_QAIC(models, chat = NULL, k = 2)
}
\arguments{
\item{models}{A list of fitted detection function models (objects returned by
\code{\link[Distance:ds]{Distance::ds()}} or \code{\link[=ct_fit_ds]{ct_fit_ds()}}).}

\item{chat}{Optional numeric value of overdispersion (\eqn{\hat{c}}). If not provided,
it is estimated from the most parameterised model in each key function set.}

\item{k}{Numeric. The penalty term used in QAIC (default is \code{2}).}
}
\value{
A tibble with one row per model containing:
\itemize{
\item \code{model}: The model name
\item \code{df}: The degrees of freedom for the model.
\item \code{QAIC}: The computed QAIC value.
}
}
\description{
Calculates the quasi-Akaike Information Criterion (QAIC) for one or more
detection function models within the same key function family.
If multiple models are provided, all must have the same key function.
This function is typically used as the first step of a two-step model selection
approach (Howe et al., 2019).
}
\details{
If only one model is supplied and \code{chat} is not provided, the function
estimates \eqn{\hat{c}} using the provided model and issues a warning that
model selection cannot be performed. For multiple models, All models must use the same key function.

QAIC is calculated as:
\deqn{QAIC = -2 \times \log(L) / \hat{c} + 2k}
where \eqn{L} is the likelihood, \eqn{\hat{c}} is the estimated
overdispersion, and \eqn{k} is the number of parameters.
}
\examples{
\donttest{
library(Distance)
library(dplyr)

data("duiker")
duiker_data <- duikers$DaytimeDistances \%>\%
  dplyr::slice_sample(prop = .3) # sample 30\% of rows
truncation <- list(left = 2, right = 15) # Keep only distance between 2-15 m

# fit hazard-rate key models
w3_hr0 <- ds(duiker_data, transect = "point", key = "hr", adjustment = NULL,
             truncation = truncation)
w3_hr1 <- ds(duiker_data, transect = "point", key = "hr", adjustment = "cos",
             order = 2, truncation = truncation)
w3_hr2 <- ds(duiker_data, transect = "point", key = "hr", adjustment = "cos",
             order = c(2, 4), truncation = truncation)
# fit half-normal key models
w3_hn0 <- ds(duiker_data, transect = "point", key = "hn", adjustment = NULL,
             truncation = truncation)
w3_hn1 <- ds(duiker_data, transect = "point", key = "hn", adjustment = "cos",
             order = 2, truncation = truncation)
w3_hn2 <- ds(duiker_data, transect = "point", key = "hn", adjustment = "cos",
             order = c(2, 4), truncation = truncation)
# fit uniform key models
w3_u0 <- ds(duiker_data, transect = "point", key = "unif", adjustment = NULL,
            truncation = truncation)
w3_u1 <- ds(duiker_data, transect = "point", key = "unif", adjustment = "cos",
            order = 2, truncation = truncation)
w3_u2 <- ds(duiker_data, transect = "point", key = "unif", adjustment = "cos",
            order = c(2, 4), truncation = truncation)

# Create model list
model_list <- list(w3_hn0, w3_hn1, w3_hn2,
                   w3_hr0, w3_hr1, w3_hr2,
                   w3_u0, w3_u1, w3_u2)

# Compute model QAICs
ct_QAIC(list(w3_hr0, w3_hr1, w3_hr2)) # All key functions must be the same
ct_QAIC(list(w3_hn0, w3_hn1, w3_hn2)) # All key functions must be the same

# Compute Chi-squared Goodness-of-fit
ct_chi2_select(list(w3_hn0, w3_hr0, w3_u0)) # All key functions must be different
ct_chi2_select(list(w3_hn2, w3_hr1, w3_u0)) # All key functions must be different

# Two-step model selection
ct_select_model(model_list)
}

}
\references{
Howe, E. J., Buckland, S. T., Després‐Einspenner, M., & Kühl, H. S. (2019).
Model selection with overdispersed distance sampling data. \strong{Methods in Ecology and Evolution},
10(1), 38-47. \doi{10.1111/2041-210X.13082}
}
